/*
 * Copyright 2011 Jens Dietrich Licensed under the GNU AFFERO GENERAL PUBLIC LICENSE, Version 3
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 * http://www.gnu.org/licenses/agpl.html Unless required by applicable law
 * or agreed to in writing, software distributed under the License is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

package test.nz.ac.massey.cs.guery.softwareantipatterns;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import javax.swing.JFileChooser;
import nz.ac.massey.cs.gql4jung.TypeNode;
import nz.ac.massey.cs.gql4jung.TypeRef;
import nz.ac.massey.cs.gql4jung.io.JarReader;
import nz.ac.massey.cs.guery.ComputationMode;
import nz.ac.massey.cs.guery.Motif;
import nz.ac.massey.cs.guery.MotifInstance;
import nz.ac.massey.cs.guery.MotifReader;
import nz.ac.massey.cs.guery.adapters.jungalt.JungAdapter;
import nz.ac.massey.cs.guery.impl.GQLImpl;
import nz.ac.massey.cs.guery.io.dsl.DefaultMotifReader;
import nz.ac.massey.cs.guery.util.ResultCollector;
import edu.uci.ics.jung.graph.DirectedGraph;


/**
 * Utility to create junit feeder methods.
 * Note that the data generated by this script have to be manually verified by inspecting the respective packages.
 * Then they can be used to test/benchmark different query engine configurations.
 * @author jens dietrich
 */

public class TestGenerator {
	public static void main(String[] args) throws Exception {
		//String src = "data/log4j-1.2.15.jar";
		DirectedGraph<TypeNode, TypeRef> g = null;
		Motif<TypeNode, TypeRef> motif = null;
		
		File file = null;
		final JFileChooser fc = new JFileChooser();
		fc.setCurrentDirectory(new File("testdata"));
		fc.setDialogTitle("Select jar file for test data generation");
		int returnVal = fc.showOpenDialog(null);
		
		
		if (returnVal == JFileChooser.APPROVE_OPTION) {
            file = fc.getSelectedFile();
            JarReader reader = new JarReader(file);
    		g = reader.readGraph();
		}
		else {
			System.err.println("No jar file selected, JVM will exit");
			System.exit(0);
		}
		System.out.println("Graph read from " + file.getAbsolutePath());
		System.out.println("Vertices in " + file.getName() + ": " + g.getVertexCount() );
		System.out.println("Edges in " + file.getName() + ": " + g.getEdgeCount() );
		String graphName = file.getName();
		
		//final JFileChooser fc = new JFileChooser();
		fc.setCurrentDirectory(new File("testdata"));
		fc.setDialogTitle("Select motif file");
		returnVal = fc.showOpenDialog(null);

		
		if (returnVal == JFileChooser.APPROVE_OPTION) {
            file = fc.getSelectedFile();
            InputStream in = new FileInputStream(file);
            MotifReader<TypeNode,TypeRef> reader = new DefaultMotifReader<TypeNode,TypeRef>();
    		motif = reader.read(in);
    		in.close();
		}
		else {
			System.err.println("No query file selected, JVM will exit");
			System.exit(0);
		}
		System.out.println("Motif read from " + file.getAbsolutePath());
		

		ResultCollector<TypeNode,TypeRef> collector = new ResultCollector<TypeNode,TypeRef>();
		new GQLImpl<TypeNode,TypeRef>().query(new JungAdapter<TypeNode,TypeRef>(g), motif, collector, ComputationMode.ALL_INSTANCES);
		
		System.out.println("Found " + collector.getInstances().size() + " motif instances" );
		
		int count = 0;
		
		System.out.println("\nGenerated method returning expected results for a graph/motif combination:\n\n");
		
		System.out.println("// motif: " + motif.getName());
		System.out.println("// data: " + graphName);
		System.out.println("public static final int EXPECTED_RESULT_COUNT_" + motif.getName() + " = " + collector.getInstances().size()+";");
		System.out.println("public static final List<Map<String,String>> EXPECTED_RESULTS_" + motif.getName() + " = getExpectedResults_" + motif.getName() + "();");
		System.out.println("private static Collection<Map<String,String>> getExpectedResults_" + motif.getName() + "() {" );
		System.out.println("\tCollection<Map<String,String>> results = new HashSet<Map<String,String>>();" );
		System.out.println("\tMap<String,String> result = null;" );
		int MAX = 100;
		Set<MotifInstance<TypeNode,TypeRef>> controlSet = new HashSet<MotifInstance<TypeNode,TypeRef>>();
		System.out.println();
		while (controlSet.size()<Math.min(MAX,collector.getInstances().size()) ) {
			MotifInstance<TypeNode,TypeRef> mi = collector.getInstances().get(new Random().nextInt(collector.getInstances().size()));
			if (controlSet.add(mi)) {
				printRecord(mi,count,Math.min(MAX,collector.getInstances().size()));
				count = count+1;
			}
			
		}
		System.out.println();
		System.out.println("\treturn results;" );
		System.out.println("}" );
		System.exit(0);
		
	}
	
	private static void printRecord(MotifInstance<TypeNode,TypeRef> mi,int count,int MAX) {
		Motif<TypeNode,TypeRef> motif = mi.getMotif();
		List<String> roles = motif.getRoles();
		
		System.out.println("\tresult = new HashMap<String,String>();");
		for (int i=0;i<roles.size();i++) {
			String role = roles.get(i);
			System.out.print("\tresult.put(\"");
			System.out.print(role);
			System.out.print("\",\"");
			System.out.print(mi.getVertex(role).getFullname());	
			System.out.println("\");");
		
		}
		System.out.println("\tresults.add(result);");	
		System.out.println();	
		
	}
}
